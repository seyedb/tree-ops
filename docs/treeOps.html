<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>treeOps API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>treeOps</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import tree
import re
import string

def list_to_tree(dlist, rootVal=None, balanced=False):
    &#34;&#34;&#34;Constructs a binary tree (BST or AVL) from a given list of node data.

    NOTE:
        - if balanced=True the rebalancing procedure (consisting of tree rotations) may lead to a 
        tree where rootVal is not necessarily the root. 
        - if rootVal=None (default) the first element of dlist will be assgined to rootVal.

    Args:
        dlist (list): list of node data.
        rootVal (node val data type): value of the root node, may or may not be from dlist.
        balanced (boolean): if True the result will be a balanced tree.
    Returns:
        (tree) a BST from the given data list.
    &#34;&#34;&#34;
    t = tree.tree()

    if rootVal is None:
        try:
            rootVal = dlist[0]
        except IndexError:
            print(&#34;Error! dlist, the list of node data, is empty.&#34;)
            return None

    t.add_node(rootVal, balanced)

    try:
        dlist.remove(rootVal)
    except ValueError:
        pass

    for data in dlist:
        t.add_node(data, balanced)

    return t

def dict_to_tree(tdict, root_ind=0): 
    &#34;&#34;&#34;Converts a (2D) nested dictionary (node adjacency information) to a tree. Can be used to 
    create an arbitrary binary tree with distinct node values.

    NOTE:
        - the input dictionary should have the follwing format: 
          {n1: {&#39;left&#39;: n3, &#39;right&#39;: &#39;None&#39;}, n2: {&#39;left&#39;: &#39;None&#39;, &#39;right&#39;: n4}, ...}
          the string value &#39;None&#39; represents a None-type treeNode
    
    Args:
        tdict (nested dict): the dictionary containing tree data with the above-mentioned format.
        root_ind (int): the index of the node in the dictionary that will be the tree root.
    Returns:
        (tree) a binary tree with data consistent with the provided tree data dictionary.
    &#34;&#34;&#34;
    assert(root_ind in range(len(tdict))), &#34;Error! Invalid root index.&#34;

    ndata_list = []
    nodes = []

    for ndata in tdict.keys():
        ndata_list.append(ndata)
        nodes.append(tree.tree().treeNode(ndata))

    t = tree.tree(nodes[root_ind])

    for ndata, children in tdict.items():

        n_ind = ndata_list.index(ndata)
        n = nodes[n_ind]

        if children[&#39;left&#39;] != &#39;None&#39;:
            l_ind = ndata_list.index(children[&#39;left&#39;])
            lnode = nodes[l_ind]
            lnode.parent = n
        else:
            lnode = None

        if children[&#39;right&#39;] != &#39;None&#39;:
            r_ind = ndata_list.index(children[&#39;right&#39;])
            rnode = nodes[r_ind]
            rnode.parent = n
        else:
            rnode = None

        n.left = lnode
        n.right = rnode

    t.update_height()
    t.update_balance_factor()

    return t

def balance_by_recursion(inTree):
    &#34;&#34;&#34;Converts a given binary tree (may or may not be BST) to a balanced binary tree by recursion
    in the following steps:
        - creates a sorted list of nodes from the input tree using an inorder traversal path;
        - constructs a balanced tree recursively from a sorted list of nodes:
            1- find the middle of the list and make it the root;
            2- get the middle left half of the list and make it the left node of the step 1;
            3- get the middle right half of the list and make it the right node of the step 1.

    Args:
        inTree (tree) input tree.
    Returns:
        (tree) a balanced binary tree containing the data/nodes from the given binary tree.
    &#34;&#34;&#34;
    path = inTree.inorder_traversal(inTree.root)
    rnode = inTree._balanceByRecursion(path, 0, len(path) - 1)
    balancedt = tree.tree(rnode)

    return balancedt

def convert_to_AVL(inTree):
    &#34;&#34;&#34;Converts a given tree (may or may not be BST) to a balanced (AVL) tree.

    Args:
        inTree (tree) input tree.
    Returns:
        (tree) a balanced (AVL) tree containing the data/nodes from the given tree.
    &#34;&#34;&#34;
    avlTree = tree.tree()
    inTree._convertToAVL(inTree.root, avlTree)

    return avlTree

def text_to_tree(path, regex=&#34;&#34;, balanced=False):
    &#34;&#34;&#34;Splits a text into paragraphs, splits each paragraph into words and stores those words in a tree.

    NOTE:
        - Uses regular expressions and split function to extract words. Like any machine learning problem
        dealing with text data, the challenge is how clean the words are desired to be. Here the choice of 
        the regex can affect the words that are extracted, a more sophisticated option would be using 
        libraries like NLTK.
        Some regex examples:
            regex=&#34;[&#34;+string.punctuation+&#34;]&#34; would remove punctuations but also contractions like &#34;don&#39;t&#34; will
            become &#34;dont&#34; and numbers like &#34;2.3&#34; will become &#34;23&#34;
            regex=&#34;(?&lt;!\d )[&#34;+string.punctuation+&#34;](?!\d)&#34;, acts as above but numbers will remain unchanged.
        - The size of the returned list is equal to the number of non-empty paragraphs in the text.

    Args:
        path (str): path to the input file.
        regex (str): regular expression used while splitting paragraph into words.
        balanced (boolean): if True the constructed trees will be balanced.
    Returns:
        (list of tree) a list of trees where each tree stores words found in any (non-empty) paragraph.
    &#34;&#34;&#34;
    with open(path, &#39;r&#39;) as fid:
        txtdata = fid.read()
        paragraphs = txtdata.split(&#39;\n\n&#39;)

    parlist = list(filter(None, paragraphs))

    treelist = []
    for paragraph in parlist:
        par = paragraph.replace(&#39;\n&#39;, &#39; &#39;).replace(&#39;\r&#39;, &#39;&#39;)
        wordlist = re.sub(regex,&#39;&#39;,par).split()
        if len(wordlist) &gt; 0:
            # use default rootVal
            t = list_to_tree(wordlist, balanced=balanced)
            treelist.append(t)

    return treelist

def find_word(wrd, indIntv, path, regex=&#34;&#34;, balanced=False):
    &#34;&#34;&#34;Searches for a word in a given text file: Splits a text into paragraphs, splits each paragraph into 
    words and stores those words in a tree, then searches for the word in every tree.

    NOTE:
        - See comment of the routine text_to_tree.
        - Paragraphs are indexed in a 0-based fashion.

    Args:
        wrd (str): the word to be searched for.
        indIntv (int list): interval of paragraph indices, search will be limited to the paragraphs with
                indices within the interval.
        path (str): path to the input file.
        regex (str): regular expression used while splitting paragraph into words.
        balanced (boolean): if True the constructed trees will be balanced.
    Returns:
        (list of int) index of paragraphs that contain the target word. 
    &#34;&#34;&#34;
    res = []

    treelist = text_to_tree(path, regex=regex, balanced=balanced)
    print(&#34;The file has {} (non-empty) paragraphs (0-index based).&#34;.format(len(treelist)-1))

    indIntv.sort()
    s1, e1 = indIntv
    s2, e2 = [0, len(treelist)-1]
    if s2 &gt; e1 or s1 &gt; e2:
        print(&#34;Invalid interval!&#34;)
        return res
    else:
        start = max(s1, s2)
        end = min(e1, e2)
        print(&#34;Searching for &#39;{}&#39; in paragraphs indexed within: [{}, {}]&#34;.format(wrd, start, end))

    for pn in list(range(start, end+1)):
        if wrd in treelist[pn]:
            res.append(pn)

    return res

def bnums_to_btree(length):
    &#34;&#34;&#34;Maps all binary numbers of a given lenght into a perfect full binary tree in a way that a path from
    root down to any leaf represents a binary number.

    Args:
        length (int): the length of binary numbers.
    Returns:
        (tree) a perfect full binary tree of height length.
    &#34;&#34;&#34;
    root = tree.tree().treeNode(&#39;root&#39;)
    btree = tree.tree(root)
    s = 2**length - 1
    for _ in range(s):
        btree.insert_node(0)
        btree.insert_node(1)

    return btree

class CBQP(object):
    &#34;&#34;&#34;Constrained Binary Quadratic Problems&#34;&#34;&#34;
    def __init__(self, n, Q, A, b):
        &#34;&#34;&#34;Initializes a constrained binary quadratic optimization problem of the form: min tr(x)*Q*x, s.t. A*x &lt;= b.
           Attributes:
                binary_length (int): the length of the binary input.
                Q (list of list): the cost matrix (coefficient matrix of the objective function).
                A (list of list): the constriant matrix.
                b (list): the right-hand-side of the constraint.
                optimal_value (float): the optimal solution of the optimization problem.
                solution (list): the binary vector that led to an optimal solution.
        &#34;&#34;&#34;
        self.binary_length = n
        self.Q = Q
        self.A = A
        self.b = b
        self.optimal_value = float(&#39;inf&#39;)
        self.solution = None

    def solve_CBQP(self):
        &#34;&#34;&#34;Solves a constrained binary quadratic optimization problem.
        Returns:
            (tuple of list and float) the first element is the solution to the problem and the second
            element is the optimal value of the objective function.
        &#34;&#34;&#34;
        btree = to.bnums_to_btree(self.binary_length)
        self._solve(btree, btree.root, [])
        return (self.solution, self.optimal_value)

    def _isFeasible(self, x):
        &#34;&#34;&#34;(helper function) Checks whether or not an element satisfies the constraint: A*x &lt;= b&#34;&#34;&#34;
        np_x = np.asarray(x)
        np_r = np.dot(self.A, np_x)
        return np.all(np_r &lt;= np.asarray(self.b))

    def _evalObjFunc(self, x):
        &#34;&#34;&#34;(helper function) Evaluates the objective function: tr(x)*Q*x&#34;&#34;&#34;
        np_x = np.asarray(x)
        obj = np.dot(np.dot(np_x, self.Q), np_x)
        return float(obj)

    def _solve(self, t, start, path):
        &#34;&#34;&#34;(helper function) Solves a constrained binary quadratic optimization problem using root-to-leaf
        paths of a perfect full binary tree with node values 0 and 1.

        Args:
            t (tree): a perfect full binary tree with node values 0 and 1, storing binary numbers of length self.binary_length.
            start (treeNode): the root of the (sub)tree where tree traversal starts.
            path (list of treeNode): a root-to-leaf path of the tree.
        Returns:
            (list) binary number of length self.binary_length that solves the optimization problem.
            (float) the optimal value of the objective function (stored in self.optimal_value)
        &#34;&#34;&#34;
        if start is None:
            return

        if len(path) == 0: path.append(start)

        if start.right is None and start.left is None:
            x = [n.data for n in path[1:]]
            if self._isFeasible(x):
                sol = _evalObjFunc(x, self.Q)
                if (sol &lt; self.optimal_value):
                    self.optimal_value = sol
                    self.solution = x

        children = []
        if start.left is not None: children.append(start.left)
        if start.right is not None: children.append(start.right)

        for child in children:
            path.append(child)
            self._solve(t, child, path)

        if (len(path) &gt; 0): path.pop()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="treeOps.balance_by_recursion"><code class="name flex">
<span>def <span class="ident">balance_by_recursion</span></span>(<span>inTree)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a given binary tree (may or may not be BST) to a balanced binary tree by recursion
in the following steps:
- creates a sorted list of nodes from the input tree using an inorder traversal path;
- constructs a balanced tree recursively from a sorted list of nodes:
1- find the middle of the list and make it the root;
2- get the middle left half of the list and make it the left node of the step 1;
3- get the middle right half of the list and make it the right node of the step 1.</p>
<h2 id="args">Args</h2>
<p>inTree (tree) input tree.</p>
<h2 id="returns">Returns</h2>
<p>(tree) a balanced binary tree containing the data/nodes from the given binary tree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def balance_by_recursion(inTree):
    &#34;&#34;&#34;Converts a given binary tree (may or may not be BST) to a balanced binary tree by recursion
    in the following steps:
        - creates a sorted list of nodes from the input tree using an inorder traversal path;
        - constructs a balanced tree recursively from a sorted list of nodes:
            1- find the middle of the list and make it the root;
            2- get the middle left half of the list and make it the left node of the step 1;
            3- get the middle right half of the list and make it the right node of the step 1.

    Args:
        inTree (tree) input tree.
    Returns:
        (tree) a balanced binary tree containing the data/nodes from the given binary tree.
    &#34;&#34;&#34;
    path = inTree.inorder_traversal(inTree.root)
    rnode = inTree._balanceByRecursion(path, 0, len(path) - 1)
    balancedt = tree.tree(rnode)

    return balancedt</code></pre>
</details>
</dd>
<dt id="treeOps.bnums_to_btree"><code class="name flex">
<span>def <span class="ident">bnums_to_btree</span></span>(<span>length)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps all binary numbers of a given lenght into a perfect full binary tree in a way that a path from
root down to any leaf represents a binary number.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>the length of binary numbers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(tree) a perfect full binary tree of height length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bnums_to_btree(length):
    &#34;&#34;&#34;Maps all binary numbers of a given lenght into a perfect full binary tree in a way that a path from
    root down to any leaf represents a binary number.

    Args:
        length (int): the length of binary numbers.
    Returns:
        (tree) a perfect full binary tree of height length.
    &#34;&#34;&#34;
    root = tree.tree().treeNode(&#39;root&#39;)
    btree = tree.tree(root)
    s = 2**length - 1
    for _ in range(s):
        btree.insert_node(0)
        btree.insert_node(1)

    return btree</code></pre>
</details>
</dd>
<dt id="treeOps.convert_to_AVL"><code class="name flex">
<span>def <span class="ident">convert_to_AVL</span></span>(<span>inTree)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a given tree (may or may not be BST) to a balanced (AVL) tree.</p>
<h2 id="args">Args</h2>
<p>inTree (tree) input tree.</p>
<h2 id="returns">Returns</h2>
<p>(tree) a balanced (AVL) tree containing the data/nodes from the given tree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_to_AVL(inTree):
    &#34;&#34;&#34;Converts a given tree (may or may not be BST) to a balanced (AVL) tree.

    Args:
        inTree (tree) input tree.
    Returns:
        (tree) a balanced (AVL) tree containing the data/nodes from the given tree.
    &#34;&#34;&#34;
    avlTree = tree.tree()
    inTree._convertToAVL(inTree.root, avlTree)

    return avlTree</code></pre>
</details>
</dd>
<dt id="treeOps.dict_to_tree"><code class="name flex">
<span>def <span class="ident">dict_to_tree</span></span>(<span>tdict, root_ind=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a (2D) nested dictionary (node adjacency information) to a tree. Can be used to
create an arbitrary binary tree with distinct node values.</p>
<h2 id="note">Note</h2>
<ul>
<li>the input dictionary should have the follwing format:
{n1: {'left': n3, 'right': 'None'}, n2: {'left': 'None', 'right': n4}, &hellip;}
the string value 'None' represents a None-type treeNode</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tdict</code></strong> :&ensp;<code>nested dict</code></dt>
<dd>the dictionary containing tree data with the above-mentioned format.</dd>
<dt><strong><code>root_ind</code></strong> :&ensp;<code>int</code></dt>
<dd>the index of the node in the dictionary that will be the tree root.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(tree) a binary tree with data consistent with the provided tree data dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dict_to_tree(tdict, root_ind=0): 
    &#34;&#34;&#34;Converts a (2D) nested dictionary (node adjacency information) to a tree. Can be used to 
    create an arbitrary binary tree with distinct node values.

    NOTE:
        - the input dictionary should have the follwing format: 
          {n1: {&#39;left&#39;: n3, &#39;right&#39;: &#39;None&#39;}, n2: {&#39;left&#39;: &#39;None&#39;, &#39;right&#39;: n4}, ...}
          the string value &#39;None&#39; represents a None-type treeNode
    
    Args:
        tdict (nested dict): the dictionary containing tree data with the above-mentioned format.
        root_ind (int): the index of the node in the dictionary that will be the tree root.
    Returns:
        (tree) a binary tree with data consistent with the provided tree data dictionary.
    &#34;&#34;&#34;
    assert(root_ind in range(len(tdict))), &#34;Error! Invalid root index.&#34;

    ndata_list = []
    nodes = []

    for ndata in tdict.keys():
        ndata_list.append(ndata)
        nodes.append(tree.tree().treeNode(ndata))

    t = tree.tree(nodes[root_ind])

    for ndata, children in tdict.items():

        n_ind = ndata_list.index(ndata)
        n = nodes[n_ind]

        if children[&#39;left&#39;] != &#39;None&#39;:
            l_ind = ndata_list.index(children[&#39;left&#39;])
            lnode = nodes[l_ind]
            lnode.parent = n
        else:
            lnode = None

        if children[&#39;right&#39;] != &#39;None&#39;:
            r_ind = ndata_list.index(children[&#39;right&#39;])
            rnode = nodes[r_ind]
            rnode.parent = n
        else:
            rnode = None

        n.left = lnode
        n.right = rnode

    t.update_height()
    t.update_balance_factor()

    return t</code></pre>
</details>
</dd>
<dt id="treeOps.find_word"><code class="name flex">
<span>def <span class="ident">find_word</span></span>(<span>wrd, indIntv, path, regex='', balanced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for a word in a given text file: Splits a text into paragraphs, splits each paragraph into
words and stores those words in a tree, then searches for the word in every tree.</p>
<h2 id="note">Note</h2>
<ul>
<li>See comment of the routine text_to_tree.</li>
<li>Paragraphs are indexed in a 0-based fashion.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrd</code></strong> :&ensp;<code>str</code></dt>
<dd>the word to be searched for.</dd>
<dt><strong><code>indIntv</code></strong> :&ensp;<code>int list</code></dt>
<dd>interval of paragraph indices, search will be limited to the paragraphs with
indices within the interval.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the input file.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>str</code></dt>
<dd>regular expression used while splitting paragraph into words.</dd>
<dt><strong><code>balanced</code></strong> :&ensp;<code>boolean</code></dt>
<dd>if True the constructed trees will be balanced.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(list of int) index of paragraphs that contain the target word.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_word(wrd, indIntv, path, regex=&#34;&#34;, balanced=False):
    &#34;&#34;&#34;Searches for a word in a given text file: Splits a text into paragraphs, splits each paragraph into 
    words and stores those words in a tree, then searches for the word in every tree.

    NOTE:
        - See comment of the routine text_to_tree.
        - Paragraphs are indexed in a 0-based fashion.

    Args:
        wrd (str): the word to be searched for.
        indIntv (int list): interval of paragraph indices, search will be limited to the paragraphs with
                indices within the interval.
        path (str): path to the input file.
        regex (str): regular expression used while splitting paragraph into words.
        balanced (boolean): if True the constructed trees will be balanced.
    Returns:
        (list of int) index of paragraphs that contain the target word. 
    &#34;&#34;&#34;
    res = []

    treelist = text_to_tree(path, regex=regex, balanced=balanced)
    print(&#34;The file has {} (non-empty) paragraphs (0-index based).&#34;.format(len(treelist)-1))

    indIntv.sort()
    s1, e1 = indIntv
    s2, e2 = [0, len(treelist)-1]
    if s2 &gt; e1 or s1 &gt; e2:
        print(&#34;Invalid interval!&#34;)
        return res
    else:
        start = max(s1, s2)
        end = min(e1, e2)
        print(&#34;Searching for &#39;{}&#39; in paragraphs indexed within: [{}, {}]&#34;.format(wrd, start, end))

    for pn in list(range(start, end+1)):
        if wrd in treelist[pn]:
            res.append(pn)

    return res</code></pre>
</details>
</dd>
<dt id="treeOps.list_to_tree"><code class="name flex">
<span>def <span class="ident">list_to_tree</span></span>(<span>dlist, rootVal=None, balanced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a binary tree (BST or AVL) from a given list of node data.</p>
<h2 id="note">Note</h2>
<ul>
<li>if balanced=True the rebalancing procedure (consisting of tree rotations) may lead to a
tree where rootVal is not necessarily the root. </li>
<li>if rootVal=None (default) the first element of dlist will be assgined to rootVal.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dlist</code></strong> :&ensp;<code>list</code></dt>
<dd>list of node data.</dd>
<dt><strong><code>rootVal</code></strong> :&ensp;<code>node val data type</code></dt>
<dd>value of the root node, may or may not be from dlist.</dd>
<dt><strong><code>balanced</code></strong> :&ensp;<code>boolean</code></dt>
<dd>if True the result will be a balanced tree.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(tree) a BST from the given data list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_to_tree(dlist, rootVal=None, balanced=False):
    &#34;&#34;&#34;Constructs a binary tree (BST or AVL) from a given list of node data.

    NOTE:
        - if balanced=True the rebalancing procedure (consisting of tree rotations) may lead to a 
        tree where rootVal is not necessarily the root. 
        - if rootVal=None (default) the first element of dlist will be assgined to rootVal.

    Args:
        dlist (list): list of node data.
        rootVal (node val data type): value of the root node, may or may not be from dlist.
        balanced (boolean): if True the result will be a balanced tree.
    Returns:
        (tree) a BST from the given data list.
    &#34;&#34;&#34;
    t = tree.tree()

    if rootVal is None:
        try:
            rootVal = dlist[0]
        except IndexError:
            print(&#34;Error! dlist, the list of node data, is empty.&#34;)
            return None

    t.add_node(rootVal, balanced)

    try:
        dlist.remove(rootVal)
    except ValueError:
        pass

    for data in dlist:
        t.add_node(data, balanced)

    return t</code></pre>
</details>
</dd>
<dt id="treeOps.text_to_tree"><code class="name flex">
<span>def <span class="ident">text_to_tree</span></span>(<span>path, regex='', balanced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Splits a text into paragraphs, splits each paragraph into words and stores those words in a tree.</p>
<h2 id="note">Note</h2>
<ul>
<li>Uses regular expressions and split function to extract words. Like any machine learning problem
dealing with text data, the challenge is how clean the words are desired to be. Here the choice of
the regex can affect the words that are extracted, a more sophisticated option would be using
libraries like NLTK.
Some regex examples:
regex="["+string.punctuation+"]" would remove punctuations but also contractions like "don't" will
become "dont" and numbers like "2.3" will become "23"
regex="(?&lt;!\d )<a href="?!\d">"+string.punctuation+"</a>", acts as above but numbers will remain unchanged.</li>
<li>The size of the returned list is equal to the number of non-empty paragraphs in the text.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to the input file.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>str</code></dt>
<dd>regular expression used while splitting paragraph into words.</dd>
<dt><strong><code>balanced</code></strong> :&ensp;<code>boolean</code></dt>
<dd>if True the constructed trees will be balanced.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(list of tree) a list of trees where each tree stores words found in any (non-empty) paragraph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text_to_tree(path, regex=&#34;&#34;, balanced=False):
    &#34;&#34;&#34;Splits a text into paragraphs, splits each paragraph into words and stores those words in a tree.

    NOTE:
        - Uses regular expressions and split function to extract words. Like any machine learning problem
        dealing with text data, the challenge is how clean the words are desired to be. Here the choice of 
        the regex can affect the words that are extracted, a more sophisticated option would be using 
        libraries like NLTK.
        Some regex examples:
            regex=&#34;[&#34;+string.punctuation+&#34;]&#34; would remove punctuations but also contractions like &#34;don&#39;t&#34; will
            become &#34;dont&#34; and numbers like &#34;2.3&#34; will become &#34;23&#34;
            regex=&#34;(?&lt;!\d )[&#34;+string.punctuation+&#34;](?!\d)&#34;, acts as above but numbers will remain unchanged.
        - The size of the returned list is equal to the number of non-empty paragraphs in the text.

    Args:
        path (str): path to the input file.
        regex (str): regular expression used while splitting paragraph into words.
        balanced (boolean): if True the constructed trees will be balanced.
    Returns:
        (list of tree) a list of trees where each tree stores words found in any (non-empty) paragraph.
    &#34;&#34;&#34;
    with open(path, &#39;r&#39;) as fid:
        txtdata = fid.read()
        paragraphs = txtdata.split(&#39;\n\n&#39;)

    parlist = list(filter(None, paragraphs))

    treelist = []
    for paragraph in parlist:
        par = paragraph.replace(&#39;\n&#39;, &#39; &#39;).replace(&#39;\r&#39;, &#39;&#39;)
        wordlist = re.sub(regex,&#39;&#39;,par).split()
        if len(wordlist) &gt; 0:
            # use default rootVal
            t = list_to_tree(wordlist, balanced=balanced)
            treelist.append(t)

    return treelist</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="treeOps.CBQP"><code class="flex name class">
<span>class <span class="ident">CBQP</span></span>
<span>(</span><span>n, Q, A, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Constrained Binary Quadratic Problems</p>
<p>Initializes a constrained binary quadratic optimization problem of the form: min tr(x)<em>Q</em>x, s.t. A*x &lt;= b.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>binary_length</code></strong> :&ensp;<code>int</code></dt>
<dd>the length of the binary input.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>list</code> of <code>list</code></dt>
<dd>the cost matrix (coefficient matrix of the objective function).</dd>
<dt><strong><code>A</code></strong> :&ensp;<code>list</code> of <code>list</code></dt>
<dd>the constriant matrix.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>list</code></dt>
<dd>the right-hand-side of the constraint.</dd>
<dt><strong><code>optimal_value</code></strong> :&ensp;<code>float</code></dt>
<dd>the optimal solution of the optimization problem.</dd>
<dt><strong><code>solution</code></strong> :&ensp;<code>list</code></dt>
<dd>the binary vector that led to an optimal solution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CBQP(object):
    &#34;&#34;&#34;Constrained Binary Quadratic Problems&#34;&#34;&#34;
    def __init__(self, n, Q, A, b):
        &#34;&#34;&#34;Initializes a constrained binary quadratic optimization problem of the form: min tr(x)*Q*x, s.t. A*x &lt;= b.
           Attributes:
                binary_length (int): the length of the binary input.
                Q (list of list): the cost matrix (coefficient matrix of the objective function).
                A (list of list): the constriant matrix.
                b (list): the right-hand-side of the constraint.
                optimal_value (float): the optimal solution of the optimization problem.
                solution (list): the binary vector that led to an optimal solution.
        &#34;&#34;&#34;
        self.binary_length = n
        self.Q = Q
        self.A = A
        self.b = b
        self.optimal_value = float(&#39;inf&#39;)
        self.solution = None

    def solve_CBQP(self):
        &#34;&#34;&#34;Solves a constrained binary quadratic optimization problem.
        Returns:
            (tuple of list and float) the first element is the solution to the problem and the second
            element is the optimal value of the objective function.
        &#34;&#34;&#34;
        btree = to.bnums_to_btree(self.binary_length)
        self._solve(btree, btree.root, [])
        return (self.solution, self.optimal_value)

    def _isFeasible(self, x):
        &#34;&#34;&#34;(helper function) Checks whether or not an element satisfies the constraint: A*x &lt;= b&#34;&#34;&#34;
        np_x = np.asarray(x)
        np_r = np.dot(self.A, np_x)
        return np.all(np_r &lt;= np.asarray(self.b))

    def _evalObjFunc(self, x):
        &#34;&#34;&#34;(helper function) Evaluates the objective function: tr(x)*Q*x&#34;&#34;&#34;
        np_x = np.asarray(x)
        obj = np.dot(np.dot(np_x, self.Q), np_x)
        return float(obj)

    def _solve(self, t, start, path):
        &#34;&#34;&#34;(helper function) Solves a constrained binary quadratic optimization problem using root-to-leaf
        paths of a perfect full binary tree with node values 0 and 1.

        Args:
            t (tree): a perfect full binary tree with node values 0 and 1, storing binary numbers of length self.binary_length.
            start (treeNode): the root of the (sub)tree where tree traversal starts.
            path (list of treeNode): a root-to-leaf path of the tree.
        Returns:
            (list) binary number of length self.binary_length that solves the optimization problem.
            (float) the optimal value of the objective function (stored in self.optimal_value)
        &#34;&#34;&#34;
        if start is None:
            return

        if len(path) == 0: path.append(start)

        if start.right is None and start.left is None:
            x = [n.data for n in path[1:]]
            if self._isFeasible(x):
                sol = _evalObjFunc(x, self.Q)
                if (sol &lt; self.optimal_value):
                    self.optimal_value = sol
                    self.solution = x

        children = []
        if start.left is not None: children.append(start.left)
        if start.right is not None: children.append(start.right)

        for child in children:
            path.append(child)
            self._solve(t, child, path)

        if (len(path) &gt; 0): path.pop()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="treeOps.CBQP.solve_CBQP"><code class="name flex">
<span>def <span class="ident">solve_CBQP</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves a constrained binary quadratic optimization problem.</p>
<h2 id="returns">Returns</h2>
<p>(tuple of list and float) the first element is the solution to the problem and the second
element is the optimal value of the objective function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_CBQP(self):
    &#34;&#34;&#34;Solves a constrained binary quadratic optimization problem.
    Returns:
        (tuple of list and float) the first element is the solution to the problem and the second
        element is the optimal value of the objective function.
    &#34;&#34;&#34;
    btree = to.bnums_to_btree(self.binary_length)
    self._solve(btree, btree.root, [])
    return (self.solution, self.optimal_value)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="treeOps.balance_by_recursion" href="#treeOps.balance_by_recursion">balance_by_recursion</a></code></li>
<li><code><a title="treeOps.bnums_to_btree" href="#treeOps.bnums_to_btree">bnums_to_btree</a></code></li>
<li><code><a title="treeOps.convert_to_AVL" href="#treeOps.convert_to_AVL">convert_to_AVL</a></code></li>
<li><code><a title="treeOps.dict_to_tree" href="#treeOps.dict_to_tree">dict_to_tree</a></code></li>
<li><code><a title="treeOps.find_word" href="#treeOps.find_word">find_word</a></code></li>
<li><code><a title="treeOps.list_to_tree" href="#treeOps.list_to_tree">list_to_tree</a></code></li>
<li><code><a title="treeOps.text_to_tree" href="#treeOps.text_to_tree">text_to_tree</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="treeOps.CBQP" href="#treeOps.CBQP">CBQP</a></code></h4>
<ul class="">
<li><code><a title="treeOps.CBQP.solve_CBQP" href="#treeOps.CBQP.solve_CBQP">solve_CBQP</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>